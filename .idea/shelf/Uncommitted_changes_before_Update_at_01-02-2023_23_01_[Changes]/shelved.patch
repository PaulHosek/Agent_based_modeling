Index: geo_model2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\r\n\r\nimport mesa\r\nimport os\r\n\r\nos.environ['USE_PYGEOS'] = '0'\r\nimport mesa_geo as mg\r\nimport pandas as pd\r\n\r\nimport country2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom scipy.stats.mstats import gmean\r\nimport time\r\n\r\n\r\nclass GeoModel(mesa.Model):\r\n    def __init__(self, cost_clean=.5, cost_dirty=.2, base_output_dirty=0.6, base_output_clean=0.1,\r\n                 metabolism_scalar_energy=1.5, metabolism_scalar_money=1, eta_global_trade=0.01,\r\n                 predisposition_decrease=0.000_1, pareto_optimal=False):\r\n\r\n        # initialise global model parameters\r\n        self.step_nr = 0\r\n        self.schedule = mesa.time.RandomActivation(self)\r\n\r\n        # trackers\r\n        self.gini = 0\r\n        self.prop_clean = 0\r\n        self.more_clean = 0\r\n        self.more_dirty = 0\r\n        self.timestep = 0\r\n        self.dom = ''\r\n        self.clean_overtake = 0\r\n        self.var_welfare = 0\r\n        self.average_welfare = 0.01\r\n        self.average_price = 0\r\n        self.var_price = 0\r\n        self.avg_pred_dirty = 0.5\r\n        self.avg_pred_clean = 0.5\r\n        self.avg_nr_dirty = 0\r\n        self.avg_nr_clean = 0\r\n        self.trading_volume = 0\r\n\r\n        self.quantitiy_max_traded = 0.01\r\n        # P(trade with everyone)\r\n        self.eta_trading = eta_global_trade\r\n        self.pareto_optimal = pareto_optimal\r\n\r\n        # initialise space\r\n        self.space = mg.GeoSpace(crs=\"4326\")\r\n\r\n        # add countries to space\r\n\r\n        ac = mg.AgentCreator(agent_class=country2.Country, model=self)\r\n        self.agents = ac.from_file(\"final_eu_countries.geojson\", unique_id=\"NAME\")\r\n        self.space.add_agents(self.agents)\r\n\r\n        # load countries and set model parameters\r\n        self.metab_e_scalar: float = float(metabolism_scalar_energy)\r\n        self.metab_m_scalar: float = float(metabolism_scalar_money)\r\n\r\n        # parameters equivalent to taxation, subsidies and sanktions\r\n        for agent in self.agents:\r\n            agent.cost_clean: float = float(cost_clean)\r\n            agent.cost_dirty: float = float(cost_dirty)\r\n            agent.output_single_dirty: float = float(base_output_dirty)\r\n            agent.output_single_clean: float = float(base_output_clean)\r\n            agent.predisposition_decrease = predisposition_decrease\r\n\r\n        self.datacollector = mesa.datacollection.DataCollector(model_reporters={\"Price\": 'average_price',\r\n                                                                                \"Welfare\": 'average_welfare',\r\n                                                                                \"Gini\": 'gini',\r\n\r\n                                                                                \"avg_nr_dirty\": 'avg_nr_dirty',\r\n                                                                                \"avg_nr_clean\": 'avg_nr_clean',\r\n\r\n                                                                                \"nr_dirty\": 'avg_nr_dirty',\r\n                                                                                \"nr_clean\": 'avg_nr_clean',\r\n\r\n                                                                                \"var_price\": 'var_price',\r\n                                                                                \"Pred_clean\": 'avg_pred_clean',\r\n                                                                                \"Trading_volume\": 'trading_volume',\r\n                                                                                \"proportion_clean\": \"prop_clean\",\r\n                                                                                \"clean_overtake\": \"clean_overtake\",\r\n                                                                                \"more_clean\": \"more_clean\",\r\n                                                                                \"more_dirty\": \"more_dirty\",\r\n                                                                                \"dominating_type\": \"dom\",\r\n                                                                                \"var_welfare\": \"var_welfare\",\r\n                                                                                \"Pred_dirty\": 'avg_pred_dirty'},\r\n                                                               agent_reporters={\"Welfare\": \"welfare\",\r\n                                                                                \"nr_dirty\": \"nr_dirty\",\r\n                                                                                \"nr_clean\": \"nr_clean\",\r\n                                                                                \"w_energy\": \"w_energy\",\r\n                                                                                \"w_money\": \"w_money\"})\r\n        # self.load_countries()\r\n        self.init_random()\r\n\r\n        self.log_data()\r\n\r\n    def load_countries(self):\r\n        \"\"\"\r\n        Initialise the country and fill the attributes from csv.\r\n        All values have been sourced from real data and scaled into [0,1] using min-max scaling.\r\n        Only \"Percentage_GDP_expenditure\" was not altered.\r\n\r\n        :return: None\r\n        \"\"\"\r\n        pred_dirties = np.empty(len(self.agents))\r\n        pred_cleans = np.empty(len(self.agents))\r\n\r\n        # print(rands)\r\n        rands1 = np.random.uniform(low=0.01, size=len(self.agents))\r\n        rands2 = np.random.uniform(low=0.01, size=len(self.agents))\r\n\r\n        data = pd.read_csv(\"energy_model_v2.csv\", sep=\",\")\r\n        for i, agent in enumerate(self.agents):\r\n            self.schedule.add(agent)\r\n            agent_data = data.loc[data['Country'] == agent.unique_id].reset_index()\r\n\r\n            # effective power plant output\r\n            agent.pred_dirty = float(agent_data.at[0, \"pred_dirty\"])\r\n            agent.pred_clean = float(agent_data.at[0, \"pred_clean\"])\r\n\r\n            pred_dirties[i] = float(agent_data.at[0, \"pred_dirty\"]) * 10\r\n            pred_cleans[i] = float(agent_data.at[0, \"pred_clean\"]) * 10\r\n            # energy\r\n            agent.m_energy = agent_data.at[0, \"energy_demand\"] * \\\r\n                             self.metab_e_scalar\r\n            # money\r\n            agent.influx_money = agent_data.at[0, \"gdp_influx\"]\r\n\r\n            agent.m_money = agent_data.at[0, \"Percentage_GDP_expenditure\"] * \\\r\n                            agent_data.at[0, \"gdp_influx\"] * self.metab_m_scalar\r\n\r\n            agent.w_money = np.random.uniform(low=0.01, high=agent.influx_money)\r\n            agent.w_energy = np.random.uniform(low=0.01, high=agent.influx_money)\r\n\r\n            # new\r\n            # agent.w_energy = rands[i]\r\n\r\n            if agent.m_energy <= 0:\r\n                agent.m_energy = 0.001\r\n            if agent.m_money <= 0:\r\n                agent.m_money = 0.001\r\n            for attr in [\"pred_dirty\", \"pred_clean\", \"influx_money\"]:\r\n                if getattr(agent, attr) <= 0:\r\n                    setattr(agent, attr, 0.001)\r\n            # need to collect to initialise wealth\r\n            agent.collect()\r\n            agent.calculate_welfare()\r\n            agent.calculate_mrs()\r\n\r\n        # plt.figure()\r\n        # # Plot a histogram of the values\r\n        # plt.hist(pred_dirties, bins=50, edgecolor='black',alpha = 0.5,label = 'dirty')\r\n        # plt.hist(pred_cleans, bins=50, edgecolor='black',alpha = 0.5,label = 'clean')\r\n        #\r\n        # # Add labels and title\r\n        # plt.xlabel('Values')\r\n        # plt.ylabel('Frequency')\r\n        # plt.legend()\r\n        # plt.title('Distribution of Values')\r\n\r\n        # Show plot\r\n        # plt.show()\r\n\r\n    def init_random(self):\r\n        rng = np.random.default_rng()\r\n        rands = np.random.uniform(low=0.01, size=len(self.agents) * 8)\r\n        rands = rands.reshape((8, len(self.agents)))\r\n        for i, agent in enumerate(self.agents):\r\n            self.schedule.add(agent)\r\n            rands1 = rands[:, i]\r\n            agent.w_energy = rands1[0]\r\n            agent.w_money = rands1[1]\r\n            agent.m_energy = rands1[2] * self.metab_e_scalar\r\n            agent.m_money = rands1[3] * self.metab_m_scalar\r\n            agent.pred_dirty = rands1[4]\r\n            agent.pred_clean = rands1[5]\r\n            agent.influx_money = rands1[6]\r\n            agent.collect()\r\n            agent.calculate_welfare()\r\n            agent.calculate_mrs()\r\n\r\n    def run_model(self, nr_steps) -> None:\r\n        \"\"\"Run model for n steps.\"\"\"\r\n        for i in range(nr_steps):\r\n            self.step()\r\n\r\n    def step(self) -> None:\r\n        \"\"\"\r\n        Do single model step.\r\n        \"\"\"\r\n        self.step_nr += 1\r\n\r\n        self.schedule.step()\r\n        self.trading_cycle()\r\n        # self.tax_dirty()\r\n        print(0.6*self.avg_pred_dirty)\r\n\r\n\r\n        # def min_max(vals):\r\n        #     min_val = min(vals)\r\n        #     max_val = max(vals)\r\n        #     return [(x - min_val) / (max_val - min_val) for x in vals]\r\n\r\n        # scaled = min_max([a.welfare for a in self.agents])\r\n        # for i, a in enumerate(self.agents):\r\n        #     a.welfare = scaled[i]\r\n        self.log_data()\r\n\r\n    def trading_cycle(self) -> None:\r\n        \"\"\"Do full trading cycle.\r\n        1. Find buying countries\r\n        2. Find selling countries\r\n        3. For each country:\r\n            a. Pick a random neighbour to trade with\r\n            b. trade according to MRS ratio between countries\r\n            c. trade maximally 0.1 of a resource and leave 0.3 as a buffer\r\n                - no trade is made if the country has <0.3 of the resource of interest\r\n        \"\"\"\r\n\r\n        def fast_choice(input_list):\r\n            return input_list[np.random.randint(0, len(input_list))]\r\n\r\n        all_countries = self.agents\r\n        rng = np.random.default_rng()\r\n\r\n        for cur_country in all_countries:\r\n\r\n            # trade with everyone with probability eta\r\n            if self.eta_trading > rng.random():\r\n                all_neighs: list = self.space.get_neighbors(cur_country)\r\n            else:\r\n                all_neighs: list = self.agents\r\n\r\n            # if country is an island, don't trade\r\n            if not len(all_neighs):\r\n                cur_country.last_trade_success = False\r\n                cur_country.last_trade_price_energy = 0.0001\r\n                continue\r\n\r\n            cur_neigh = fast_choice(all_neighs)\r\n\r\n            # determine price per energy if there will be a trade\r\n            if cur_country.mrs == cur_neigh.mrs:\r\n                cur_country.last_trade_success = False\r\n                cur_neigh.last_trade_success = False\r\n                cur_country.last_trade_price_energy = 0.0001\r\n                cur_neigh.last_trade_price_energy = 0.0001\r\n\r\n                continue\r\n            else:\r\n                price: float = float(gmean([cur_country.mrs, cur_neigh.mrs], dtype=float))\r\n                if math.isnan(price):\r\n                    raise ValueError(f\"Price {price} is nan.\")\r\n\r\n            # do trades\r\n            if cur_neigh.mrs > cur_country.mrs:\r\n\r\n                # calculate how much wealth exceeds the buffer\r\n                # no trade if no buffer (0.3 energy)\r\n                energy_left = cur_neigh.w_energy - (cur_neigh.w_energy * 0.3)\r\n                money_left = cur_country.w_money - (cur_country.w_money * 0.3)\r\n                # if money_left < 0 or energy_left < 0: # TODO this os false, needs to be bigger than trade volume\r\n                #     cur_country.last_trade_success = False\r\n                #     cur_neigh.last_trade_success = False\r\n                #     cur_country.last_trade_price_energy = 0.0001\r\n                #     cur_neigh.last_trade_price_energy = 0.0001\r\n                #     continue\r\n\r\n                # determine how much is being traded\r\n                # 0.1 is the max energy allowed to be traded\r\n                # 0.3 the min level money and energy allowed\r\n\r\n                # if have less than 0.1 energy/money more than the buffer, trade everything up to buffer\r\n                if self.quantitiy_max_traded > energy_left and energy_left < money_left:\r\n                    energy = energy_left\r\n                    money = price * energy_left\r\n                elif self.quantitiy_max_traded > money_left and money_left < energy_left:\r\n                    energy = price * money_left\r\n                    money = 1 * money_left\r\n\r\n                # else trade 0.1 energy\r\n                else:\r\n                    if price > 1:\r\n                        energy = self.quantitiy_max_traded\r\n                        money = self.quantitiy_max_traded * price\r\n                    else:\r\n                        energy = self.quantitiy_max_traded / price\r\n                        money = self.quantitiy_max_traded\r\n\r\n                if energy_left < energy or money_left < money:\r\n                    cur_country.last_trade_success = False\r\n                    cur_neigh.last_trade_success = False\r\n                    cur_country.last_trade_price_energy = 0.0001\r\n                    cur_neigh.last_trade_price_energy = 0.0001\r\n                    continue\r\n\r\n                if self.pareto_optimal:\r\n                    if not self.pareto_optimality(cur_country, cur_neigh, money, energy):\r\n                        continue\r\n\r\n\r\n                # do transaction\r\n                cur_country.w_energy += energy\r\n                cur_country.w_money -= money\r\n                cur_neigh.w_money += money\r\n                cur_neigh.w_energy -= energy\r\n                cur_country.calculate_welfare()\r\n                cur_country.calculate_mrs()\r\n                cur_neigh.calculate_welfare()\r\n                cur_neigh.calculate_mrs()\r\n                self.trading_volume += 1\r\n\r\n\r\n            else:\r\n                # calculate how much wealth exceeds the buffer\r\n                # no trade if no buffer (0.3 energy)\r\n                energy_left = cur_country.w_energy - (cur_country.w_energy * 0.3)\r\n                money_left = cur_neigh.w_money - (cur_neigh.w_money * 0.3)\r\n                # if money_left < 0 or energy_left < 0:\r\n                #     cur_country.last_trade_success = False\r\n                #     cur_neigh.last_trade_success = False\r\n                #     continue\r\n\r\n                # determine how much is being traded\r\n                # 0.1 is the max energy allowed to be traded\r\n                # 0.3 the min level money and energy allowed\r\n\r\n                # if have less than 0.1 energy/money more than the buffer, trade everything up to buffer\r\n                if self.quantitiy_max_traded > energy_left and energy_left < money_left:\r\n                    energy = energy_left\r\n                    money = price * energy_left\r\n                elif self.quantitiy_max_traded > money_left and money_left < energy_left:\r\n                    energy = price * money_left\r\n                    money = 1 * money_left\r\n\r\n                # else trade 0.1 energy\r\n                else:\r\n                    if price > 1:\r\n                        energy = self.quantitiy_max_traded\r\n                        money = self.quantitiy_max_traded * price\r\n                    else:\r\n                        energy = self.quantitiy_max_traded / price\r\n                        money = self.quantitiy_max_traded\r\n\r\n                if energy_left < energy or money_left < money:\r\n                    cur_country.last_trade_success = False\r\n                    cur_neigh.last_trade_success = False\r\n                    cur_country.last_trade_price_energy = 0.0001\r\n                    cur_neigh.last_trade_price_energy = 0.0001\r\n                    continue\r\n\r\n                if self.pareto_optimal:\r\n                    if not self.pareto_optimality(cur_neigh, cur_country, money, energy):\r\n                        continue\r\n\r\n                # do transaction\r\n                cur_country.w_energy -= energy\r\n                cur_country.w_money += money\r\n                cur_neigh.w_money -= money\r\n                cur_neigh.w_energy += energy\r\n                cur_country.calculate_welfare()\r\n                cur_country.calculate_mrs()\r\n                cur_neigh.calculate_welfare()\r\n                cur_neigh.calculate_mrs()\r\n                self.trading_volume += 1\r\n\r\n            # pass information about trade to decision function in the next step\r\n            cur_country.last_trade_price_energy = price\r\n            cur_country.last_trade_success = True\r\n            cur_neigh.last_trade_price_energy = price\r\n            cur_neigh.last_trade_success = True\r\n\r\n            # cur_country.model.price_record[cur_country.model.step_num].append(price)\r\n            # cur_country.make_link(cur_neigh)\r\n    @staticmethod\r\n    def pareto_optimality(buying_c, selling_c, money, energy):\r\n        \"\"\"Test if a trade will be pareto optimal.\"\"\"\r\n\r\n        # buying country = gets energy\r\n\r\n        mt = np.add(buying_c.m_energy, buying_c.m_money)\r\n\r\n        new_welfare_b = np.power(buying_c.w_energy + buying_c.produced_energy + energy,\r\n                                 buying_c.m_energy / mt) * np.power(buying_c.w_money - money, buying_c.m_money / mt)\r\n\r\n        mt = np.add(selling_c.m_energy, selling_c.m_money)\r\n        new_welfare_s = np.power(selling_c.w_energy + selling_c.produced_energy - energy,\r\n                                 selling_c.m_energy / mt) * np.power(selling_c.w_money + money, selling_c.m_money / mt)\r\n\r\n        print(new_welfare_b, buying_c.welfare, new_welfare_s, selling_c.welfare)\r\n        if new_welfare_b < buying_c.welfare or new_welfare_s < selling_c.welfare:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n        # mt = np.add(self.m_energy, self.m_money)\r\n        # \r\n        # return np.power(self.w_energy + self.produced_energy + add_energy, self.m_energy / mt) \\\r\n        #        * np.power(self.w_money + expected_market_cost, self.m_money / mt)\r\n\r\n    def tax_dirty(self):\r\n\r\n        for agent in self.agents:\r\n            clean_plant_nr = agent.nr_clean\r\n            if agent.nr_clean <1:\r\n                clean_plant_nr = 1\r\n            ratio = agent.nr_dirty/clean_plant_nr\r\n\r\n            if ratio > 1 and ratio < 2:\r\n                agent.w_money -= agent.w_money * (ratio-1)*0.3\r\n            elif ratio > 2:\r\n                agent.w_money -= agent.w_money * 0.3\r\n\r\n            # find what ratio is\r\n            # if ratio is too high, punish\r\n\r\n    def log_data(self) -> None:\r\n        \"\"\"\r\n        Compute average values, statistics etc. of the system and self in class attributes (e.g., self.avg_energy).\r\n        Will feed to datacollector later.\r\n        :return: None\r\n        \"\"\"\r\n\r\n        def gini_coef(x, w=None):\r\n            x = np.asarray(x)\r\n            sorted_x = np.sort(x)\r\n            n = len(x)\r\n            cumx = np.cumsum(sorted_x, dtype=float)\r\n            return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n\r\n\r\n        # compute statistics of the step here\r\n        nr_agents = len(self.agents)\r\n        total_welfare = 0\r\n        prices = np.empty(nr_agents)\r\n        pred_dirty = 0\r\n        total_nr_dirty = 0\r\n        total_nr_clean = 0\r\n        welfares_list = np.empty(nr_agents)\r\n        for idx, agent in enumerate(self.agents):\r\n            total_welfare += agent.welfare\r\n            pred_dirty += agent.pred_dirty\r\n            total_nr_clean += agent.nr_clean\r\n            total_nr_dirty += agent.nr_dirty\r\n            welfares_list[idx] = agent.welfare\r\n            if agent.last_trade_price_energy != 0.0001:\r\n                prices[idx] = agent.last_trade_price_energy\r\n        self.gini = gini_coef(welfares_list)\r\n\r\n        if total_nr_clean != 0 and total_nr_dirty != 0:\r\n            self.prop_clean = total_nr_clean / (total_nr_dirty + total_nr_clean)\r\n\r\n        self.timestep += 1\r\n        if total_nr_clean > total_nr_dirty:\r\n            if self.dom == 'dirty':\r\n                self.clean_overtake = self.timestep\r\n            self.more_clean += 1\r\n            self.dom = 'clean'\r\n        elif total_nr_clean < total_nr_dirty:\r\n            if self.dom == 'clean':\r\n                self.clean_overtake = self.timestep\r\n            self.more_dirty += 1\r\n            self.dom = 'dirty'\r\n\r\n        self.average_welfare = total_welfare / nr_agents\r\n        self.avg_pred_dirty = pred_dirty / nr_agents\r\n        self.avg_nr_dirty = total_nr_dirty / nr_agents\r\n        self.avg_nr_clean = total_nr_clean / nr_agents\r\n\r\n        # print(self.average_welfare)\r\n\r\n        self.average_price = np.mean(prices)\r\n        self.var_price = np.var(prices)\r\n        self.var_welfare = np.var(welfares_list)\r\n        self.datacollector.collect(self)\r\n        self.trading_volume = 0\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    pd.set_option('display.max_columns', None)\r\n\r\n    now = time.time()\r\n    new = GeoModel()\r\n    new.run_model(1500)\r\n    print(time.time() - now)\r\n    data = new.datacollector.get_model_vars_dataframe()\r\n    # print(data)\r\n    a_data = new.datacollector.get_agent_vars_dataframe()\r\n    df_by_country_m = a_data.pivot_table(values='w_money', columns='AgentID', index='Step')\r\n    df_by_country_e = a_data.pivot_table(values='w_energy', columns='AgentID', index='Step')\r\n    # df_by_country_e = a_data.pivot_table(values = 'w_money', columns = 'AgentID', index = 'Step')\r\n    # print(\"Welfare\")\r\n    # print(a_data.pivot_table(values='Welfare', columns='AgentID', index='Step'))\r\n    # print(\"w_energy\")\r\n    # print(df_by_country_e)\r\n\r\n    plt.figure()\r\n    plt.title(\"energy\")\r\n    plt.plot(df_by_country_e, color='red', alpha =0.3)\r\n    plt.show()\r\n\r\n    plt.figure()\r\n    plt.ylabel(\"Money\")\r\n    plt.xlabel(\"Timesteps, t\")\r\n    plt.plot(df_by_country_m, color='green', alpha=0.3)\r\n    plt.show()\r\n\r\n    # plot welfare\r\n    plt.figure()\r\n    plt.xlabel(\"Timesteps, t\")\r\n    plt.ylabel(\"Welfare, W\")\r\n    plt.plot(data[\"Welfare\"])\r\n    plt.show()\r\n\r\n    plt.figure()\r\n    plt.xlabel(\"Timesteps, t\")\r\n    plt.ylabel(\"Average Price (1 E/m)\")\r\n    plt.plot(data[\"Price\"])\r\n    plt.show()\r\n\r\n    # plt.figure()\r\n    # plt.title(\"trading volume\")\r\n    # # plt.plot(df_by_country_m, color='green')\r\n    # plt.plot(data[\"Trading_volume\"])\r\n    # plt.show()\r\n\r\n    # print()\r\n    # print(\"Welfare by country\\n\")\r\n    # print(df_by_country[:30])\r\n\r\n    # plt.figure()\r\n    # plt.title(\"wealth\")\r\n    # plt.plot(a_data.pivot_table(values='w_energy', columns='AgentID', index='Step'), color='red', label='energy')\r\n    # plt.plot(a_data.pivot_table(values='w_money', columns='AgentID', index='Step'), color='green', label='money')\r\n    # plt.show()\r\n    # print(\"WELFARE MAX\")\r\n    # my_pivot = a_data.pivot_table(values='Welfare', columns='AgentID', index='Step')\r\n    # print(my_pivot.max())\r\n    #\r\n    # plt.figure()\r\n    # plt.title(\"welfare per country\")\r\n    # plt.plot(a_data.pivot_table(values='Welfare', columns='AgentID', index='Step'))\r\n    #\r\n    # plt.show()\r\n    # plt.figure()\r\n    # plt.title(\"trading vol\")\r\n    # plt.plot(data[\"Trading_volume\"])\r\n    # plt.figure()\r\n\r\n    # last_state = df_by_country.iloc[-1]\r\n    # and\r\n\r\n    # plt.title(\"nr dirty per country\")\r\n    # plt.plot(data[\"Pred_dirty\"])\r\n    # plt.plot(df_by_country)\r\n    plt.figure()\r\n    plt.ylabel(\"Number plants\")\r\n    plt.xlabel(\"Timesteps, t\")\r\n    plt.plot(data[\"nr_dirty\"], color='brown', label=\"dirty\")\r\n    plt.plot(data[\"nr_clean\"], color='green', label=\"clean\")\r\n    plt.legend()\r\n    plt.show()\r\n    # plt.semilogy(data[\"Price\"][10:])\r\n    # plt.plot(data[\"Welfare\"][10:])\r\n    # plt.xlim([10,100])\r\n    # plt.xlim([10,100])\r\n\r\n    # plt.figure()\r\n    # plt.title(\"nr dirty avg\")\r\n    # plt.plot(data[\"nr_dirty\"], color='brown')\r\n    # plt.plot(data[\"nr_clean\"], color='green')\r\n    # plt.show()\r\n\r\n    # print(a_data)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/geo_model2.py b/geo_model2.py
--- a/geo_model2.py	(revision 8087ef857c025e04d6f96771b03878830bc91aca)
+++ b/geo_model2.py	(date 1675286768697)
@@ -483,7 +483,7 @@
 
     now = time.time()
     new = GeoModel()
-    new.run_model(1500)
+    new.run_model(1000)
     print(time.time() - now)
     data = new.datacollector.get_model_vars_dataframe()
     # print(data)
Index: run_your_sobol.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from itertools import combinations\r\n\r\nimport matplotlib.pyplot as plt\r\nfrom IPython.display import clear_output\r\nimport SALib\r\nfrom SALib.sample import saltelli, sobol\r\nfrom SALib.analyze import sobol\r\nimport pandas as pd\r\nimport geo_model2\r\nfrom geo_model2 import *\r\nimport numpy as np\r\nimport time\r\n\r\nsamples = pd.read_csv(\"Sobol_256.csv\", index_col=0)\r\n# samples = samples[:51]      # PAUL\r\n# samples = samples[51:102]   # SOUVIK\r\n# samples = samples[102:153]  # TIJN\r\n# samples = samples[153:204]  # CONOR\r\n# samples = samples[204:]     # GAIA\r\n\r\n# TODO slice your region here before removing the KeyboardIntterupt\r\n\r\nraise KeyboardInterrupt\r\n#just testing\r\n\r\nprint(samples)\r\navg_last_welfare = []\r\navg_last_price = []\r\n\r\nfor i in range(len(samples)):\r\n    new = geo_model2.GeoModel(cost_clean=samples.iloc[i][0],\r\n                             cost_dirty=samples.iloc[i][1],\r\n                             base_output_dirty=samples.iloc[i][2],\r\n                             base_output_clean=samples.iloc[i][3],\r\n                             metabolism_scalar_energy= samples.iloc[i][4],\r\n                             metabolism_scalar_money= samples.iloc[i][5],\r\n                             eta_global_trade= samples.iloc[i][6],\r\n                             predisposition_decrease= samples.iloc[i][7])\r\n    new.run_model(1000)\r\n    nw1 = new.datacollector.get_agent_vars_dataframe()\r\n    nw2 = new.datacollector.get_model_vars_dataframe()\r\n    # print(nw2)\r\n\r\n    #nw2 = new.datacollector.get_model_vars_dataframe()\r\n    df_by_country_welfare = nw1.pivot_table(values = 'Welfare', columns = 'AgentID', index = 'Step')\r\n    # df_by_country_price = nw2.pivot_table(values = 'Price', columns = 'AgentID', index = 'Step')\r\n\r\n    # print(df_by_country_price)\r\n    #last_state = df_by_country.iloc[-1]\r\n    avg_last_welfare.append(np.mean(df_by_country_welfare.iloc[-1]))\r\n    avg_last_price.append(nw2.iloc[-1][0])\r\n\r\n    #print(np.mean(avg_last_welfare))\r\n#print(len(avg_last_price))\r\n\r\noutputs1 = pd.DataFrame(data = avg_last_welfare,\r\n        columns = ['output_welfare'])\r\n\r\noutputs2 = pd.DataFrame(data = avg_last_price,\r\n        columns = ['output_price'])\r\n\r\n# TODO SAVE MY DATA BITTE\r\n\r\noutputs1.to_csv(\"paul1.csv\")\r\noutputs2.to_csv(\"paul2.csv\")\r\n\r\n\r\nraise KeyboardInterrupt\r\n\r\n# print(outputs1)\r\n# print(outputs2)\r\n\r\nS_i_welfare = sobol.analyze(problem, outputs1['output_welfare'].values, print_to_console=True, calc_second_order=False)\r\n#print(S_i_welfare)\r\n\r\nS_i_price = sobol.analyze(problem, outputs2['output_price'].values, print_to_console=True, calc_second_order=False)\r\n#print(S_i_price)\r\n\r\ndef plot_index(s, params, i, title=''):\r\n    \"\"\"\r\n    Creates a plot for Sobol sensitivity analysis that shows the contributions\r\n    of each parameter to the global sensitivity.\r\n\r\n    Args:\r\n        s (dict): dictionary {'S#': dict, 'S#_conf': dict} of dicts that hold\r\n            the values for a set of parameters\r\n        params (list): the parameters taken from s\r\n        i (str): string that indicates what order the sensitivity is.\r\n        title (str): title for the plot\r\n    \"\"\"\r\n\r\n    if i == '2':\r\n        p = len(params)\r\n        params = list(combinations(params, 2))\r\n        indices = s['S' + i].reshape((p ** 2))\r\n        indices = indices[~np.isnan(indices)]\r\n        errors = s['S' + i + '_conf'].reshape((p ** 2))\r\n        errors = errors[~np.isnan(errors)]\r\n    else:\r\n        print('S' + i)\r\n        indices = s['S' + i]\r\n        errors = s['S' + i + '_conf']\r\n        plt.figure()\r\n\r\n    l = len(indices)\r\n\r\n    plt.title(title)\r\n    plt.ylim([-0.2, len(indices) - 1 + 0.2])\r\n    plt.yticks(range(l), params)\r\n    plt.errorbar(indices, range(l), xerr=errors, linestyle='None', marker='o')\r\n    plt.axvline(0, c='k')\r\nplt.figure()\r\nfor Si in [S_i_welfare]:\r\n    # First order\r\n    plot_index(Si, problem['names'], '1', 'Welfare First order sensitivity')\r\n    # plt.show()\r\n    # Second order\r\n    # plot_index(Si, problem['names'], '2', 'Second order sensitivity')\r\n    #     plt.show()\r\n    # Total order\r\n    plot_index(Si, problem['names'], 'T', 'Welfare Total order sensitivity')\r\n    #plt.show()\r\n\r\n\r\n# for S in [S_i_price]:\r\n#     # First order\r\n#     plot_index(S, problem['names'], '1', 'Price First order sensitivity')\r\n#     # plt.show()\r\n#     # Second order\r\n#     # plot_index(S, problem['names'], '2', 'Second order sensitivity')\r\n#     #     plt.show()\r\n#     # Total order\r\n#     plot_index(S, problem['names'], 'T', 'Price Total order sensitivity')\r\nprint(time.time() - now)\r\nplt.show()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/run_your_sobol.py b/run_your_sobol.py
--- a/run_your_sobol.py	(revision 8087ef857c025e04d6f96771b03878830bc91aca)
+++ b/run_your_sobol.py	(date 1675270426942)
@@ -36,7 +36,7 @@
                              metabolism_scalar_money= samples.iloc[i][5],
                              eta_global_trade= samples.iloc[i][6],
                              predisposition_decrease= samples.iloc[i][7])
-    new.run_model(1000)
+    new.run_model(10)
     nw1 = new.datacollector.get_agent_vars_dataframe()
     nw2 = new.datacollector.get_model_vars_dataframe()
     # print(nw2)
@@ -65,7 +65,7 @@
 outputs2.to_csv("paul2.csv")
 
 
-raise KeyboardInterrupt
+#raise KeyboardInterrupt
 
 # print(outputs1)
 # print(outputs2)
Index: country2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import mesa\r\nimport mesa_geo as mg\r\nimport typing\r\nimport geo_model\r\nimport numpy as np\r\nimport math\r\n\r\n\r\nclass Country(mg.GeoAgent):\r\n    def __init__(self, unique_id, model, geometry, crs,\r\n                 m_energy=0.1, m_money=0.1, w_energy=0.01, w_money=0.01, predisposition_decrease=0.0001):\r\n\r\n        \"\"\"\r\n        :param unique_id: Name of country\r\n        :param model:\r\n        :param geometry:\r\n        \"\"\"\r\n        super().__init__(unique_id, model, geometry, crs)\r\n        # attributes\r\n        self.name: str = 'na'\r\n        # self.metabolism: dict = metabolism\r\n        # self.wealth: dict = wealth\r\n        self.welfare: float = 0.001\r\n        self.mrs: float = 0.001\r\n        self.produced_energy: float = 0.001\r\n        self.influx_money: float = 0.001\r\n        self.w_money = w_money\r\n        self.w_energy = w_energy\r\n        self.m_money = m_money\r\n        self.m_energy = m_energy\r\n\r\n        # for later\r\n        self.pred_dirty: float = 0.001\r\n        self.pred_clean: float = 0.001\r\n        self.nr_dirty: int = 0\r\n        self.nr_clean: int = 0\r\n        self.predisposition_decrease = predisposition_decrease\r\n\r\n        # attributes set by model\r\n        self.last_trade_success: bool = False\r\n        self.last_trade_price_energy: float = 0.0001  # TODO this should probs not be this\r\n        # base output of single plants as determined by the initialisation\r\n        self.output_single_dirty: float = 0.001\r\n        self.output_single_clean: float = 0.001\r\n        self.cost_dirty: float = 0.001\r\n        self.cost_clean: float = 0.001\r\n\r\n    def __repr__(self):\r\n        return f\"Country: {self.unique_id}\"\r\n\r\n    def step(self) -> None:\r\n        \"\"\"\r\n        Do agents actions in each step here.\r\n        :return:\r\n        \"\"\"\r\n        self.collect()\r\n        self.invest()\r\n        self.consume()\r\n        self.calculate_welfare()\r\n        self.calculate_mrs()\r\n        self.reduce_pred()\r\n        # self.kill_plant()\r\n        if self.w_energy > 100:\r\n            self.w_energy = 100\r\n\r\n\r\n    def collect(self) -> None:\r\n        \"\"\"Collect energy and money from power plants and gdp influx.\r\n        \"\"\"\r\n        self.w_energy += self.nr_clean * self.pred_clean * self.output_single_clean \\\r\n                         + self.nr_dirty * self.pred_dirty * self.output_single_dirty\r\n        self.w_money += self.influx_money\r\n\r\n    def invest(self) -> None:\r\n        \"\"\"\r\n        Decide if we should build a power plant or rely on trading.\r\n        1. Decide if can afford power plant\r\n        2. Do what-if analysis on welfare increase with power plant for both power plants.\r\n        3. Choose power plant that maximises welfare.\r\n        4. Build power plant\r\n        5. Compute new wealth for energy and money.\r\n        \"\"\"\r\n        # if cant afford any plant\r\n\r\n        # if self.cost_clean > self.w_money - 0.1 and self.cost_dirty > self.w_money - 0.1:\r\n        #     return\r\n\r\n        if self.cost_clean > self.w_money - (self.w_money * 0.3) \\\r\n                and self.cost_dirty > self.w_money - (self.w_money * 0.3):\r\n            return\r\n\r\n        # if self.build_neighbour_plant():\r\n        #     return\r\n\r\n        # print(\"COST\", self.cost_clean, self.w_money)\r\n\r\n        build_d_welfare = self.would_be_welfare(\"dirty\")\r\n        build_c_welfare = self.would_be_welfare(\"clean\")\r\n        trade_d_welfare = self.would_be_welfare(\"trade_e\")\r\n        trade_c_welfare = self.would_be_welfare(\"trade_m\")\r\n\r\n        options = [\r\n            [build_d_welfare, self.cost_dirty, \"dirty\"],\r\n            [build_c_welfare, self.cost_clean, \"clean\"],\r\n            [trade_d_welfare, 0, \"trade\"],\r\n            [trade_c_welfare, 0, \"trade\"]\r\n        ]\r\n        options = [x for x in options if not math.isnan(x[1])]\r\n\r\n        # sort options by welfare\r\n\r\n        options.sort(reverse=True, key=lambda x: x[0])\r\n        options = sorted(options, reverse=True, key=lambda x: x[0])\r\n\r\n\r\n\r\n\r\n        # build their plant\r\n        # skip the rest of the decisio\r\n\r\n        # print(\"Options\", options)\r\n        # choose first option we can afford\r\n        best = next((x for x in options if x[1] < self.w_money - (self.w_money * 0.3) and not math.isnan(x[1])),\r\n                    (trade_c_welfare, 0, \"trade\"))\r\n        if best[2] == \"dirty\" or best[2] == \"clean\":\r\n            # print(best[2])\r\n            self.build_plant(best[2])\r\n\r\n        # if last trade was not successful, but the best option was trade. Try to build the best plant we can.\r\n        # elif best[2] == \"trade\" and not self.last_trade_success:\r\n        #     # if there are any plants we can afford, build the one with the highest welfare\r\n        #     best_build = sorted((x for x in options\r\n        #                          if (x[2] == \"dirty\" or x[2] == \"clean\") and x[1] < self.w_money - (self.w_money * 0.3)),\r\n        #                         reverse=True, key=lambda x: x[0])\r\n        #     if best_build:\r\n        #         self.build_plant(best_build[0][2])\r\n        # else:\r\n        #     pass\r\n    def build_neighbour_plant(self):\r\n        influence, their_plant = self.neighbour_influence()\r\n        if influence > np.random.uniform():\r\n            if their_plant == \"clean\" and self.cost_clean > self.w_money - (self.w_money * 0.3):\r\n                self.build_plant(\"clean\")\r\n                return True\r\n            elif their_plant == \"dirty\" and self.cost_dirty > self.w_money - (self.w_money * 0.3):\r\n                self.build_plant(\"dirty\")\r\n                return True\r\n        return False\r\n\r\n    def neighbour_influence(self):\r\n\r\n        all_neigh = sorted(self.model.space.get_neighbors(self), key=lambda x: x.welfare, reverse=True)\r\n        if not all_neigh:\r\n            return 0, \"\"\r\n        best_neigh = all_neigh[0]\r\n\r\n        influence = 1-(self.welfare/best_neigh.welfare) if best_neigh.welfare != 0 else 0\r\n        if best_neigh.nr_dirty > best_neigh.nr_clean:\r\n            plant = \"dirty\"\r\n        elif best_neigh.nr_dirty < best_neigh.nr_clean:\r\n            plant = \"clean\"\r\n\r\n        # if equal then try to make own plants equal too\r\n        else:\r\n            if self.nr_clean < self.nr_dirty:\r\n                plant = \"clean\"\r\n            elif self.nr_dirty < self.nr_clean:\r\n                plant = \"dirty\"\r\n            else:\r\n                return 0, \"\"\r\n\r\n        return influence, plant\r\n\r\n\r\n        # calculate dominant plant\r\n        # calculate 1-my_welfare/their_welfare => influence factor\r\n        # return influence_factor, plant\r\n\r\n    # if influnce_factor > np.random.uniform() and if can afford:\r\n            # build their plant\r\n            # skip the rest of the decision\r\n\r\n\r\n\r\n\r\n\r\n        # test if my is larger then break or sth\r\n\r\n    def would_be_welfare(self, action: str, trading_quantity = 0.1) -> float:\r\n        if action == \"dirty\":\r\n            add_energy = self.pred_dirty * self.output_single_dirty\r\n            expected_market_cost = self.cost_dirty\r\n        elif action == \"clean\":\r\n            add_energy = self.pred_clean * self.output_single_clean\r\n            expected_market_cost = self.cost_clean\r\n        elif action == \"trade_e\":  # TODO make sure right operations\r\n            # sell energy\r\n            add_energy = -trading_quantity\r\n            expected_market_cost = trading_quantity * self.last_trade_price_energy\r\n        elif action == \"trade_m\":\r\n            # sell money\r\n            add_energy = trading_quantity / self.last_trade_price_energy\r\n            expected_market_cost = - trading_quantity\r\n        else:\r\n            raise ValueError(\r\n                f\"Variable action is {action} but can only take values 'dirty', 'clean', 'trade_e' or 'trade_m'.\")\r\n\r\n        mt = np.add(self.m_energy, self.m_money)\r\n\r\n        return np.power(self.w_energy + self.produced_energy + add_energy, self.m_energy / mt) \\\r\n               * np.power(self.w_money + expected_market_cost, self.m_money / mt)\r\n\r\n    def consume(self) -> None:\r\n        \"\"\"Use up energy and money\"\"\"\r\n        self.w_energy -= self.m_energy\r\n        self.w_money -= self.m_money * self.w_money\r\n        if self.w_energy < 0:\r\n            self.w_energy = 0.01\r\n        if self.w_money < 0:\r\n            self.w_money = 0.01\r\n\r\n    def calculate_welfare(self) -> None:\r\n        \"\"\"\r\n        Calculate welfare according to Cobb-Douglas production formula.\r\n        Include both influx of\r\n        money and produced energy from plants in equation.\r\n        m1 = demand of energy taken from energy consumption data of a country\r\n        m2 = demand of money taken from public expenditure data of a country\r\n        W(e,m) = (energy + production_from_plants) ^ (m1/mt) * (money + influx from gdp) ^ (m2/mt)\r\n        \"\"\"\r\n\r\n        mt = np.add(self.m_energy, self.m_money)\r\n\r\n        w_energy = np.power(np.add(self.w_energy, self.produced_energy),\r\n                            np.divide(self.m_energy, mt))\r\n        w_money = np.power(np.add(self.w_money, self.influx_money),\r\n                           np.divide(self.m_money, mt))\r\n\r\n        for i in [w_money, w_energy]:\r\n            if isinstance(i, complex):\r\n                i = 0\r\n\r\n        self.welfare = np.multiply(w_money, w_energy)\r\n\r\n    def calculate_mrs(self) -> None:\r\n        \"\"\"Calculate Marginal Rate of Substitution (MRS).\"\"\"\r\n        self.mrs = np.divide(np.multiply(np.add(self.w_energy, self.produced_energy), self.m_money),\r\n                             np.multiply(np.add(self.w_money, self.influx_money), self.m_energy))\r\n\r\n    def build_plant(self, type_plant: str):\r\n        \"\"\"\r\n        Build some plant,\r\n        :param: type_plant: The plant to build. Either \"dirty\" or \"clean\".\r\n        :return:\r\n        \"\"\"\r\n        if type_plant == \"dirty\":\r\n            self.nr_dirty += 1\r\n            self.w_money -= self.cost_dirty\r\n        elif type_plant == 'clean':\r\n            self.nr_clean += 1\r\n            self.w_money -= self.cost_clean\r\n        else:\r\n            raise ValueError(f\"\"\"{type_plant} is not a valid plant. Use the tag \"dirty\" or \"clean\".\"\"\")\r\n\r\n    def kill_plant(self):\r\n        # for plant in [self.nr_dirty, self.nr_clean]:\r\n        if 0.2 > np.random.random() and self.nr_dirty > 0:\r\n            self.nr_dirty -= 1\r\n        if 0.2 > np.random.random() and self.nr_clean > 0:\r\n            self.nr_clean -= 1\r\n\r\n    def reduce_pred(self):\r\n        \"\"\"\r\n        Reduce predisposition of dirty power based on how many power plants consume it.\r\n        \"\"\"\r\n        self.pred_dirty -= self.nr_dirty * self.predisposition_decrease\r\n        if self.pred_dirty < 0:\r\n            self.pred_dirty = 0\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/country2.py b/country2.py
--- a/country2.py	(revision 8087ef857c025e04d6f96771b03878830bc91aca)
+++ b/country2.py	(date 1675288507500)
@@ -89,8 +89,9 @@
                 and self.cost_dirty > self.w_money - (self.w_money * 0.3):
             return
 
-        # if self.build_neighbour_plant():
-        #     return
+
+         if self.build_neighbour_plant():
+             return
 
         # print("COST", self.cost_clean, self.w_money)
 
Index: Souvik2.csv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>,output_price\r\n0,260721.47286179342\r\n1,1.0000086615680477\r\n2,1.0000088606470634\r\n3,1.000009068130989\r\n4,1.0000090482975519\r\n5,1.0000094969136692\r\n6,1.0000094366223617\r\n7,1.000009648269375\r\n8,1.0000023006561103\r\n9,1.0000022764549683\r\n10,1.0000023023116127\r\n11,1.000001846377391\r\n12,1.0000018536373843\r\n13,1.0000018132046957\r\n14,1.000001857965676\r\n15,1.0000018704104945\r\n16,1.000001815511903\r\n17,1.0000018672714102\r\n18,1.0000016007509138\r\n19,1.000001640772751\r\n20,1.000001661335818\r\n21,1.0000014997796927\r\n22,1.0000014613652828\r\n23,1.0000014923765592\r\n24,1.000001501133637\r\n25,1.0000014694685688\r\n26,1.00000148225905\r\n27,1.0000014976193217\r\n28,1.0000014801113635\r\n29,1.0000014445240362\r\n30,1.0000014128863275\r\n31,1.0000011022189566\r\n32,1.0000010698966382\r\n33,1.000001043940634\r\n34,1.0000010454349666\r\n35,1.0000010359790839\r\n36,1.0000010421411647\r\n37,1.000001028097203\r\n38,1.0000010494777367\r\n39,1.000001049112697\r\n40,1.0000010059800761\r\n41,1.0000010303966842\r\n42,1.000001039610179\r\n43,1.000001043022378\r\n44,1.000001032756305\r\n45,1.000001040865272\r\n46,1.000001055460665\r\n47,1.0000010617747868\r\n48,1.0000010348543025\r\n49,1.0000010635458887\r\n50,1.000001052313407\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Souvik2.csv b/Souvik2.csv
--- a/Souvik2.csv	(revision 8087ef857c025e04d6f96771b03878830bc91aca)
+++ b/Souvik2.csv	(date 1675270426953)
@@ -1,52 +1,52 @@
 ,output_price
-0,260721.47286179342
-1,1.0000086615680477
-2,1.0000088606470634
-3,1.000009068130989
-4,1.0000090482975519
-5,1.0000094969136692
-6,1.0000094366223617
-7,1.000009648269375
-8,1.0000023006561103
-9,1.0000022764549683
-10,1.0000023023116127
-11,1.000001846377391
-12,1.0000018536373843
-13,1.0000018132046957
-14,1.000001857965676
-15,1.0000018704104945
-16,1.000001815511903
-17,1.0000018672714102
-18,1.0000016007509138
-19,1.000001640772751
-20,1.000001661335818
-21,1.0000014997796927
-22,1.0000014613652828
-23,1.0000014923765592
-24,1.000001501133637
-25,1.0000014694685688
-26,1.00000148225905
-27,1.0000014976193217
-28,1.0000014801113635
-29,1.0000014445240362
-30,1.0000014128863275
-31,1.0000011022189566
-32,1.0000010698966382
-33,1.000001043940634
-34,1.0000010454349666
-35,1.0000010359790839
-36,1.0000010421411647
-37,1.000001028097203
-38,1.0000010494777367
-39,1.000001049112697
-40,1.0000010059800761
-41,1.0000010303966842
-42,1.000001039610179
-43,1.000001043022378
-44,1.000001032756305
-45,1.000001040865272
-46,1.000001055460665
-47,1.0000010617747868
-48,1.0000010348543025
-49,1.0000010635458887
-50,1.000001052313407
+0,1.0970762323121026
+1,18.300317860123414
+2,0.027729271353386913
+3,0.018758796796767556
+4,0.07301227727655052
+5,0.027875376911019868
+6,0.032690541246956153
+7,0.11809790313856475
+8,23.417496485599152
+9,1.1051491710016488
+10,7.574366434494966
+11,109.0549385900115
+12,1.0178655482438255
+13,1.0167279516499381
+14,1.0227567066395287
+15,2.3475449027108577
+16,26.783152523732724
+17,17.708552076225853
+18,316.89529653753414
+19,1.0194907276555472
+20,0.01888768790041892
+21,43.43074550244832
+22,0.9099565498321802
+23,8.512010763762795
+24,5.229218362662302
+25,4.674706525610079
+26,1.5030854224930374
+27,2.7465695391849767
+28,2.5367626407532864
+29,6.838784516664141
+30,1.0359641987983084
+31,1.026077267837039
+32,1.0265586109190266
+33,1.019063607687558
+34,1.0144948239128342
+35,1.0113176443602216
+36,1.0102168865308843
+37,1.0092881222801797
+38,1.0080614371591727
+39,1.008927614134986
+40,1.0114965416324166
+41,1.0176240511816195
+42,1.0432050356742733
+43,0.3635705712990243
+44,1.2673195929568337
+45,0.01434259401209288
+46,0.006229531559417101
+47,0.1646929748753287
+48,4.3649036138234845
+49,2.301953827857995
+50,3.77704839082398
Index: Souvik1.csv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>,output_welfare\r\n0,1.000008638587478\r\n1,1.0000086617112007\r\n2,1.0000088607955218\r\n3,1.0000090682856848\r\n4,1.0000090484541933\r\n5,1.0000094970801792\r\n6,1.0000094367910715\r\n7,1.0000096484469283\r\n8,1.0000022974277591\r\n9,1.0000022764639434\r\n10,1.0000023023207385\r\n11,1.000001845900189\r\n12,1.0000018536431108\r\n13,1.0000018132103339\r\n14,1.0000018579714582\r\n15,1.0000018704163511\r\n16,1.0000018155175243\r\n17,1.0000018672772746\r\n18,1.0000016003922811\r\n19,1.000001640775312\r\n20,1.0000016613403535\r\n21,1.0000014994928241\r\n22,1.0000014613678305\r\n23,1.0000014923784366\r\n24,1.000001501135849\r\n25,1.0000014694706962\r\n26,1.0000014822611543\r\n27,1.0000014976212634\r\n28,1.000001480114974\r\n29,1.0000014444015772\r\n30,1.0000014128104453\r\n31,1.0000011017434827\r\n32,1.0000010698269068\r\n33,1.0000010439413405\r\n34,1.0000010454367778\r\n35,1.0000010359224485\r\n36,1.0000010421429095\r\n37,1.0000010280989304\r\n38,1.000001049479487\r\n39,1.0000010491144549\r\n40,1.0000010059747286\r\n41,1.0000010303981282\r\n42,1.0000010396119345\r\n43,1.0000010430241328\r\n44,1.000001032758035\r\n45,1.0000010408670248\r\n46,1.0000010554624446\r\n47,1.0000010617765955\r\n48,1.0000010348554857\r\n49,1.0000010635476988\r\n50,1.0000010523151965\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Souvik1.csv b/Souvik1.csv
--- a/Souvik1.csv	(revision 8087ef857c025e04d6f96771b03878830bc91aca)
+++ b/Souvik1.csv	(date 1675270426962)
@@ -1,52 +1,52 @@
 ,output_welfare
-0,1.000008638587478
-1,1.0000086617112007
-2,1.0000088607955218
-3,1.0000090682856848
-4,1.0000090484541933
-5,1.0000094970801792
-6,1.0000094367910715
-7,1.0000096484469283
-8,1.0000022974277591
-9,1.0000022764639434
-10,1.0000023023207385
-11,1.000001845900189
-12,1.0000018536431108
-13,1.0000018132103339
-14,1.0000018579714582
-15,1.0000018704163511
-16,1.0000018155175243
-17,1.0000018672772746
-18,1.0000016003922811
-19,1.000001640775312
-20,1.0000016613403535
-21,1.0000014994928241
-22,1.0000014613678305
-23,1.0000014923784366
-24,1.000001501135849
-25,1.0000014694706962
-26,1.0000014822611543
-27,1.0000014976212634
-28,1.000001480114974
-29,1.0000014444015772
-30,1.0000014128104453
-31,1.0000011017434827
-32,1.0000010698269068
-33,1.0000010439413405
-34,1.0000010454367778
-35,1.0000010359224485
-36,1.0000010421429095
-37,1.0000010280989304
-38,1.000001049479487
-39,1.0000010491144549
-40,1.0000010059747286
-41,1.0000010303981282
-42,1.0000010396119345
-43,1.0000010430241328
-44,1.000001032758035
-45,1.0000010408670248
-46,1.0000010554624446
-47,1.0000010617765955
-48,1.0000010348554857
-49,1.0000010635476988
-50,1.0000010523151965
+0,1.079852553631542
+1,1.0838152781752053
+2,0.02759761707179398
+3,2.4403713229527293e-08
+4,0.05209446021671285
+5,0.048334991551570734
+6,6.907255569604386e-101
+7,1.2722128841988102e-100
+8,1.051640596312841
+9,1.1162301539960195
+10,1.1465412723027966
+11,1.0207433866474322
+12,1.016238612106735
+13,1.0161225439285562
+14,1.022949118704599
+15,0.738894198546807
+16,1.0847398717361574
+17,1.0507011777669637
+18,1.014257451119972
+19,1.021196869579124
+20,3.936936138484175e-101
+21,1.048281379353133
+22,1.103961322404218
+23,1.137591761192777
+24,1.1406687972293201
+25,1.1644935881220195
+26,1.014378660924855
+27,1.1684963141723914
+28,1.1311652830870196
+29,1.0431365982244651
+30,1.0297733698896059
+31,1.0232579546620792
+32,1.0240652788024562
+33,1.016851388882664
+34,1.0134219842573997
+35,1.0105184337916482
+36,1.0098815572148683
+37,1.0087603257867008
+38,1.0076733766387291
+39,1.0091930857345799
+40,1.0116309429566699
+41,1.0188475636001295
+42,1.0491912738145897
+43,0.10165148122609359
+44,0.9681725549550058
+45,2.512110216260889e-100
+46,1.3860606796629665e-100
+47,7.913826487724752e-12
+48,1.1143930556791086
+49,0.8935433803865479
+50,1.123517771561548
