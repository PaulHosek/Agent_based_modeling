Index: geo_model2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\r\n\r\nimport mesa\r\nimport os\r\n\r\nos.environ['USE_PYGEOS'] = '0'\r\nimport mesa_geo as mg\r\nimport pandas as pd\r\n\r\nimport country2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom scipy.stats.mstats import gmean\r\nimport time\r\nimport network_analysis\r\n\r\nseed = 187758\r\n\r\nnp.random.seed(seed)\r\n\r\n\r\nclass GeoModel(mesa.Model):\r\n    def __init__(self, cost_clean=.02, cost_dirty=.02, base_output_dirty=0.8, base_output_clean=0.4,\r\n                 metabolism_scalar_energy=1, metabolism_scalar_money=1, eta_global_trade=0.01,\r\n                 predisposition_decrease=0.000_01, pareto_optimal=False, seed=seed, prob_neigh_influence=0):\r\n\r\n        self.seed = seed\r\n        self.prob_neigh_influence = prob_neigh_influence\r\n\r\n        # initialise space and add countries\r\n        self.space = mg.GeoSpace(crs=\"4326\")\r\n        ac = mg.AgentCreator(agent_class=country2.Country, model=self)\r\n        self.agents = ac.from_file(\"final_eu_countries.geojson\", unique_id=\"NAME\")\r\n        self.space.add_agents(self.agents)\r\n        # initialise global model parameters\r\n        self.schedule = mesa.time.RandomActivation(self)\r\n\r\n        # Trackers\r\n        self.gini = 0\r\n        self.prop_clean = 0\r\n        self.more_clean = 0\r\n        self.more_dirty = 0\r\n        self.timestep = 0\r\n        self.dom = ''\r\n        self.clean_overtake = 0\r\n        self.var_welfare = 0\r\n        self.average_welfare = 0.01\r\n        self.average_price = 0\r\n        self.var_price = 0\r\n        self.avg_pred_dirty = 0.5\r\n        self.avg_pred_clean = 0.5\r\n        self.avg_nr_dirty = 0\r\n        self.avg_nr_clean = 0\r\n        self.trading_volume = 0\r\n        self.max_steps = 0\r\n        self.step_nr = 0\r\n        self.modularity = 0\r\n\r\n        # parameters\r\n        self.quantitiy_max_traded = 0.001\r\n        self.eta_trading = eta_global_trade\r\n        self.pareto_optimal = pareto_optimal\r\n        self.metab_e_scalar: float = float(metabolism_scalar_energy)\r\n        self.metab_m_scalar: float = float(metabolism_scalar_money)\r\n\r\n        # parameters equivalent to taxation, subsidies and sanktions\r\n        for agent in self.agents:\r\n            agent.cost_clean: float = float(cost_clean)\r\n            agent.cost_dirty: float = float(cost_dirty)\r\n            agent.output_single_dirty: float = float(base_output_dirty)\r\n            agent.output_single_clean: float = float(base_output_clean)\r\n            agent.predisposition_decrease = predisposition_decrease\r\n\r\n        self.datacollector = mesa.datacollection.DataCollector(model_reporters={\"Gini_welfare\": 'gini',\r\n                                                                                \"modularity_ga\": \"modularity\",\r\n\r\n                                                                                \"Price\": 'average_price',\r\n                                                                                \"Welfare\": 'average_welfare',\r\n\r\n                                                                                \"avg_nr_dirty\": 'avg_nr_dirty',\r\n                                                                                \"avg_nr_clean\": 'avg_nr_clean',\r\n\r\n                                                                                \"nr_dirty\": 'avg_nr_dirty',\r\n                                                                                \"nr_clean\": 'avg_nr_clean',\r\n\r\n                                                                                \"var_price\": 'var_price',\r\n                                                                                \"Pred_clean\": 'avg_pred_clean',\r\n                                                                                \"Trading_volume\": 'trading_volume',\r\n                                                                                \"proportion_clean\": \"prop_clean\",\r\n                                                                                \"clean_overtake\": \"clean_overtake\",\r\n                                                                                \"more_clean\": \"more_clean\",\r\n                                                                                \"more_dirty\": \"more_dirty\",\r\n                                                                                \"dominating_type\": \"dom\",\r\n                                                                                \"var_welfare\": \"var_welfare\",\r\n                                                                                \"Pred_dirty\": 'avg_pred_dirty'},\r\n                                                               agent_reporters={\"Welfare\": \"welfare\",\r\n                                                                                \"Clean_adoption\": \"clean_adoption\",\r\n                                                                                \"nr_dirty\": \"nr_dirty\",\r\n                                                                                \"nr_clean\": \"nr_clean\",\r\n                                                                                \"w_energy\": \"w_energy\",\r\n                                                                                \"w_money\": \"w_money\"})\r\n        self.init_random()\r\n        # self.load_countries()\r\n        self.log_data()\r\n\r\n    def log_data(self) -> None:\r\n        \"\"\"\r\n        Compute average values, statistics of the system and self in class attributes (e.g., self.avg_energy).\r\n        Will feed to datacollector later.\r\n        :return: None\r\n        \"\"\"\r\n\r\n        def gini_coef(x):\r\n            x = np.asarray(x)\r\n            sorted_x = np.sort(x)\r\n            n = len(x)\r\n            cumx = np.cumsum(sorted_x, dtype=float)\r\n            return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n\r\n\r\n        # compute statistics of the step here\r\n        nr_agents = len(self.agents)\r\n        total_welfare = 0\r\n        prices = np.empty(nr_agents)\r\n        pred_dirty = 0\r\n        total_nr_dirty = 0\r\n        total_nr_clean = 0\r\n        welfares_list = np.empty(nr_agents)\r\n        adoption_dict = dict()\r\n\r\n        for idx, agent in enumerate(self.agents):\r\n            adoption_dict[agent.unique_id] = agent.clean_adoption\r\n            welfares_list[idx] = agent.welfare\r\n\r\n            total_welfare += agent.welfare\r\n            pred_dirty += agent.pred_dirty\r\n            total_nr_clean += agent.nr_clean\r\n            total_nr_dirty += agent.nr_dirty\r\n            if agent.last_trade_price_energy != 100_000_000:\r\n                prices[idx] = agent.last_trade_price_energy\r\n\r\n        # avg proportion clean plants\r\n        if total_nr_clean != 0 and total_nr_dirty != 0:\r\n            self.prop_clean = total_nr_clean / (total_nr_dirty + total_nr_clean)\r\n\r\n        # green takeover\r\n        self.timestep += 1\r\n        if total_nr_clean > total_nr_dirty:\r\n            if self.dom == 'dirty':\r\n                self.clean_overtake = self.timestep\r\n            self.more_clean += 1\r\n            self.dom = 'clean'\r\n        elif total_nr_clean < total_nr_dirty:\r\n            if self.dom == 'clean':\r\n                self.clean_overtake = self.timestep\r\n            self.more_dirty += 1\r\n            self.dom = 'dirty'\r\n\r\n        # economic convergence\r\n        self.gini = gini_coef(welfares_list)\r\n        self.average_welfare = total_welfare / nr_agents\r\n        self.avg_pred_dirty = pred_dirty / nr_agents\r\n        self.avg_nr_dirty = total_nr_dirty / nr_agents\r\n        self.avg_nr_clean = total_nr_clean / nr_agents\r\n\r\n        # print(self.average_welfare)\r\n\r\n        self.average_price = np.mean(prices)\r\n        self.var_price = np.var(prices)\r\n        self.var_welfare = np.var(welfares_list)\r\n        self.modularity = network_analysis.estimate_modularity(adoption_dict)\r\n\r\n        self.datacollector.collect(self)\r\n        self.trading_volume = 0\r\n\r\n    def init_random(self):\r\n        rands = np.random.default_rng(self.seed).uniform(low=0.01, size=len(self.agents) * 5)\r\n        rands = rands.reshape((5, len(self.agents)))\r\n        rands_m = np.random.default_rng(self.seed).uniform(low=0.4, high=0.6, size=(len(self.agents) * 2))\r\n        rands_m = rands_m.reshape((2, len(self.agents)))\r\n\r\n        for i, agent in enumerate(self.agents):\r\n            self.schedule.add(agent)\r\n            rands1 = rands[:, i]\r\n            rands_m1 = rands[:, i]\r\n            agent.w_energy = rands1[0]\r\n            agent.w_money = rands1[1]\r\n            agent.m_energy = rands_m1[0] * self.metab_e_scalar\r\n            agent.m_money = rands_m1[1] * self.metab_m_scalar\r\n            agent.pred_dirty = rands1[2]\r\n            agent.pred_clean = rands1[3]\r\n            agent.influx_money = rands1[4]\r\n            agent.collect()\r\n            agent.calculate_welfare()\r\n            agent.calculate_mrs()\r\n\r\n    def load_countries(self):\r\n        \"\"\"\r\n        Initialise the country and fill the attributes from csv.\r\n        All values have been sourced from real data and scaled into [0,1] using min-max scaling.\r\n        Only \"Percentage_GDP_expenditure\" was not altered.\r\n\r\n        :return: None\r\n        \"\"\"\r\n        pred_dirties = np.empty(len(self.agents))\r\n        pred_cleans = np.empty(len(self.agents))\r\n\r\n        # print(rands)\r\n\r\n        data = pd.read_csv(\"energy_model_v2.csv\", sep=\",\")\r\n        for i, agent in enumerate(self.agents):\r\n            self.schedule.add(agent)\r\n            agent_data = data.loc[data['Country'] == agent.unique_id].reset_index()\r\n\r\n            # effective power plant output\r\n            agent.pred_dirty = float(agent_data.at[0, \"pred_dirty\"])\r\n            agent.pred_clean = float(agent_data.at[0, \"pred_clean\"])\r\n\r\n            pred_dirties[i] = float(agent_data.at[0, \"pred_dirty\"]) * 10\r\n            pred_cleans[i] = float(agent_data.at[0, \"pred_clean\"]) * 10\r\n            # energy\r\n            agent.m_energy = agent_data.at[0, \"energy_demand\"] * \\\r\n                             self.metab_e_scalar\r\n            # money\r\n            agent.influx_money = agent_data.at[0, \"gdp_influx\"]\r\n            agent.collect()\r\n            agent.calculate_welfare()\r\n            agent.calculate_mrs()\r\n\r\n    def run_model(self, nr_steps) -> None:\r\n        \"\"\"Run model for n steps.\"\"\"\r\n        self.max_steps = nr_steps\r\n        for i in range(nr_steps):\r\n            self.step()\r\n\r\n    def step(self) -> None:\r\n        \"\"\"\r\n        Do single model step.\r\n        \"\"\"\r\n        self.step_nr += 1\r\n\r\n        self.schedule.step()\r\n        self.trading_cycle()\r\n        self.tax_dirty()\r\n\r\n        self.log_data()\r\n\r\n    def trading_cycle(self) -> None:\r\n        \"\"\"Do full trading cycle.\r\n        1. Find buying countries\r\n        2. Find selling countries\r\n        3. For each country:\r\n            a. Pick a random neighbour to trade with\r\n            b. trade according to MRS ratio between countries\r\n            c. trade maximally 0.1 of a resource and leave 0.3 as a buffer\r\n                - no trade is made if the country has <0.3 of the resource of interest\r\n        \"\"\"\r\n\r\n        def fast_choice(input_list):\r\n            return input_list[np.random.default_rng(None).integers(0, len(input_list))]\r\n\r\n        all_countries = self.agents\r\n\r\n        for cur_country in all_countries:\r\n\r\n            # trade with everyone with probability eta\r\n            if self.eta_trading > np.random.default_rng(None).random():\r\n                all_neighs: list = self.space.get_neighbors(cur_country)\r\n            else:\r\n                all_neighs: list = self.agents\r\n\r\n            # if country is an island, don't trade\r\n            if not len(all_neighs):\r\n                cur_country.last_trade_success = False\r\n                cur_country.last_trade_price_energy = 100_000_000\r\n                continue\r\n\r\n            cur_neigh = fast_choice(all_neighs)\r\n\r\n            # determine price per energy if there will be a trade\r\n            if cur_country.mrs == cur_neigh.mrs:\r\n                cur_country.last_trade_success = False\r\n                cur_neigh.last_trade_success = False\r\n                cur_country.last_trade_price_energy = 100_000_000\r\n                cur_neigh.last_trade_price_energy = 100_000_000\r\n\r\n                continue\r\n            else:\r\n                price: float = float(gmean([cur_country.mrs, cur_neigh.mrs], dtype=float))\r\n                if math.isnan(price):\r\n                    raise ValueError(f\"Price {price} is nan.\")\r\n\r\n            # do trades\r\n            if cur_neigh.mrs > cur_country.mrs:\r\n\r\n                # calculate how much wealth exceeds the buffer\r\n                # no trade if no buffer (0.3 energy)\r\n                energy_left = cur_neigh.w_energy - (cur_neigh.w_energy * 0.3)\r\n                money_left = cur_country.w_money - (cur_country.w_money * 0.3)\r\n                # if money_left < 0 or energy_left < 0: # TODO this os false, needs to be bigger than trade volume\r\n                #     cur_country.last_trade_success = False\r\n                #     cur_neigh.last_trade_success = False\r\n                #     cur_country.last_trade_price_energy = 0.0001\r\n                #     cur_neigh.last_trade_price_energy = 0.0001\r\n                #     continue\r\n\r\n                # determine how much is being traded\r\n                # 0.1 is the max energy allowed to be traded\r\n                # 0.3 the min level money and energy allowed\r\n\r\n                # if have less than 0.1 energy/money more than the buffer, trade everything up to buffer\r\n                if self.quantitiy_max_traded > energy_left and energy_left < money_left:\r\n                    energy = energy_left\r\n                    money = price * energy_left\r\n                elif self.quantitiy_max_traded > money_left and money_left < energy_left:\r\n                    energy = price * money_left\r\n                    money = 1 * money_left\r\n\r\n                # else trade 0.1 energy\r\n                else:\r\n                    if price > 1:\r\n                        energy = self.quantitiy_max_traded\r\n                        money = self.quantitiy_max_traded * price\r\n                    else:\r\n                        energy = self.quantitiy_max_traded / price\r\n                        money = self.quantitiy_max_traded\r\n\r\n                if energy_left < energy or money_left < money:\r\n                    cur_country.last_trade_success = False\r\n                    cur_neigh.last_trade_success = False\r\n                    cur_country.last_trade_price_energy = 100_000_000\r\n                    cur_neigh.last_trade_price_energy = 100_000_000\r\n                    continue\r\n\r\n                if self.pareto_optimal:\r\n                    if not self.pareto_optimality(cur_country, cur_neigh, money, energy):\r\n                        continue\r\n\r\n                # do transaction\r\n                cur_country.w_energy += energy\r\n                cur_country.w_money -= money\r\n                cur_neigh.w_money += money\r\n                cur_neigh.w_energy -= energy\r\n                cur_country.calculate_welfare()\r\n                cur_country.calculate_mrs()\r\n                cur_neigh.calculate_welfare()\r\n                cur_neigh.calculate_mrs()\r\n                self.trading_volume += 1\r\n\r\n\r\n            else:\r\n                # calculate how much wealth exceeds the buffer\r\n                # no trade if no buffer (0.3 energy)\r\n                energy_left = cur_country.w_energy - (cur_country.w_energy * 0.3)\r\n                money_left = cur_neigh.w_money - (cur_neigh.w_money * 0.3)\r\n                # if money_left < 0 or energy_left < 0:\r\n                #     cur_country.last_trade_success = False\r\n                #     cur_neigh.last_trade_success = False\r\n                #     continue\r\n\r\n                # determine how much is being traded\r\n                # 0.1 is the max energy allowed to be traded\r\n                # 0.3 the min level money and energy allowed\r\n\r\n                # if have less than 0.1 energy/money more than the buffer, trade everything up to buffer\r\n                if self.quantitiy_max_traded > energy_left and energy_left < money_left:\r\n                    energy = energy_left\r\n                    money = price * energy_left\r\n                elif self.quantitiy_max_traded > money_left and money_left < energy_left:\r\n                    energy = price * money_left\r\n                    money = 1 * money_left\r\n\r\n                # else trade 0.1 energy\r\n                else:\r\n                    if price > 1:\r\n                        energy = self.quantitiy_max_traded\r\n                        money = self.quantitiy_max_traded * price\r\n                    else:\r\n                        energy = self.quantitiy_max_traded / price\r\n                        money = self.quantitiy_max_traded\r\n\r\n                if energy_left < energy or money_left < money:\r\n                    cur_country.last_trade_success = False\r\n                    cur_neigh.last_trade_success = False\r\n                    cur_country.last_trade_price_energy = 100_000_000\r\n                    cur_neigh.last_trade_price_energy = 100_000_000\r\n                    continue\r\n\r\n                if self.pareto_optimal:\r\n                    if not self.pareto_optimality(cur_neigh, cur_country, money, energy):\r\n                        continue\r\n\r\n                # do transaction\r\n                cur_country.w_energy -= energy\r\n                cur_country.w_money += money\r\n                cur_neigh.w_money -= money\r\n                cur_neigh.w_energy += energy\r\n                cur_country.calculate_welfare()\r\n                cur_country.calculate_mrs()\r\n                cur_neigh.calculate_welfare()\r\n                cur_neigh.calculate_mrs()\r\n                self.trading_volume += 1\r\n\r\n            # pass information about trade to decision function in the next step\r\n            cur_country.last_trade_price_energy = price\r\n            cur_country.last_trade_success = True\r\n            cur_neigh.last_trade_price_energy = price\r\n            cur_neigh.last_trade_success = True\r\n\r\n            # cur_country.model.price_record[cur_country.model.step_num].append(price)\r\n            # cur_country.make_link(cur_neigh)\r\n\r\n    @staticmethod\r\n    def pareto_optimality(buying_c, selling_c, money, energy):\r\n        \"\"\"Test if a trade will be pareto optimal.\"\"\"\r\n\r\n        # buying country = gets energy\r\n\r\n        mt = np.add(buying_c.m_energy, buying_c.m_money)\r\n\r\n        new_welfare_b = np.power(buying_c.w_energy + buying_c.produced_energy + energy,\r\n                                 buying_c.m_energy / mt) * np.power(buying_c.w_money - money, buying_c.m_money / mt)\r\n\r\n        mt = np.add(selling_c.m_energy, selling_c.m_money)\r\n        new_welfare_s = np.power(selling_c.w_energy + selling_c.produced_energy - energy,\r\n                                 selling_c.m_energy / mt) * np.power(selling_c.w_money + money, selling_c.m_money / mt)\r\n\r\n        if new_welfare_b < buying_c.welfare or new_welfare_s < selling_c.welfare:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n        # mt = np.add(self.m_energy, self.m_money)\r\n        # \r\n        # return np.power(self.w_energy + self.produced_energy + add_energy, self.m_energy / mt) \\\r\n        #        * np.power(self.w_money + expected_market_cost, self.m_money / mt)\r\n\r\n    def tax_dirty(self):\r\n\r\n        for agent in self.agents:\r\n            clean_plant_nr = agent.nr_clean\r\n            if agent.nr_clean < 1:\r\n                clean_plant_nr = 1\r\n            ratio = agent.nr_dirty / clean_plant_nr\r\n\r\n            if ratio > 1 and ratio < 2:\r\n                agent.w_money -= agent.w_money * (ratio - 1) * 0.3\r\n            elif ratio > 2:\r\n                agent.w_money -= agent.w_money * 0.3\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    pd.set_option('display.max_columns', None)\r\n\r\n    now = time.time()\r\n    new = GeoModel()\r\n    new.run_model(1000)\r\n    print(time.time() - now)\r\n    data = new.datacollector.get_model_vars_dataframe()\r\n    a_data = new.datacollector.get_agent_vars_dataframe()\r\n    # plot welfare\r\n    plt.figure()\r\n    plt.xlabel(\"Timesteps, t\")\r\n    plt.ylabel(\"Modularity, M\")\r\n    plt.plot(data[\"modularity_ga\"][100:])\r\n    plt.show()\r\n\r\n    # df_by_country_m = a_data.pivot_table(values='w_money', columns='AgentID', index='Step')\r\n    # df_by_country_e = a_data.pivot_table(values='w_energy', columns='AgentID', index='Step')\r\n    # print(a_data.pivot_table(values='Welfare', columns='AgentID', index='Step'))\r\n    # a_data[\"Welfare\"].to_csv(\"Welfare_per_country.csv\")\r\n    #\r\n    #\r\n    #     # # plot welfare\r\n    plt.figure()\r\n    plt.xlabel(\"Timesteps, t\")\r\n    plt.ylabel(\"Welfare, W\")\r\n    plt.plot(data[\"Welfare\"])\r\n    plt.show()\r\n    #     # data[\"Welfare\"].to_csv(\"w_noni\")\r\n    #\r\n    #     # plt.figure()\r\n    #     # plt.xlabel(\"Timesteps, t\")\r\n    #     # plt.ylabel(\"Average Price (1 E/m)\")\r\n    #     # plt.plot(data[\"Price\"])\r\n    #     # plt.show()\r\n    #\r\n    #     plt.figure()\r\n    #     plt.title(\"Adoption\")\r\n    #     plt.plot(a_data.pivot_table(values='Clean_adoption', columns='AgentID', index='Step'), color='green')\r\n    #     plt.show()\r\n    #\r\n    #     # print()\r\n    #     # print(\"Welfare by country\\n\")\r\n    #     # print(df_by_country[:30])\r\n    #\r\n    #     # plt.figure()\r\n    #     # plt.title(\"wealth\")\r\n    #     # plt.plot(a_data.pivot_table(values='w_energy', columns='AgentID', index='Step'), color='red', label='energy')\r\n    #     # plt.plot(a_data.pivot_table(values='w_money', columns='AgentID', index='Step'), color='green', label='money')\r\n    #     # plt.show()\r\n    #     # print(\"WELFARE MAX\")\r\n    #     # my_pivot = a_data.pivot_table(values='Welfare', columns='AgentID', index='Step')\r\n    #     # print(my_pivot.max())\r\n    #     #\r\n    # plt.figure()\r\n    # plt.title(\"welfare per country\")\r\n    # plt.plot(a_data.pivot_table(values='Welfare', columns='AgentID', index='Step'))\r\n    #\r\n    # plt.show()\r\n    #     # plt.figure()\r\n    #     # plt.ylabel(\"Trading volume, #trades/t\")\r\n    #     # plt.xlabel(\"Timesteps, t\")\r\n    #     # plt.plot(data[\"Trading_volume\"])\r\n    #     # plt.show()\r\n    #     # data[\"Trading_volume\"].to_csv(\"trading_vol.csv\")\r\n    #\r\n    #     # last_state = df_by_country.iloc[-1]\r\n    #     # and\r\n    #\r\n    #     # plt.title(\"nr dirty per country\")\r\n    #     # plt.plot(data[\"Pred_dirty\"])\r\n    #     # plt.plot(df_by_country)\r\n    plt.figure()\r\n    plt.ylabel(\"Number plants\")\r\n    plt.xlabel(\"Timesteps, t\")\r\n    plt.plot(data[\"nr_dirty\"], color='brown', label=\"dirty\")\r\n    plt.plot(data[\"nr_clean\"], color='green', label=\"clean\")\r\n    plt.legend()\r\n    plt.show()\r\n#     # plt.semilogy(data[\"Price\"][10:])\r\n#     # plt.plot(data[\"Welfare\"][10:])\r\n#     # plt.xlim([10,100])\r\n#     # plt.xlim([10,100])\r\n#\r\n#     # plt.figure()\r\n#     # plt.title(\"nr dirty avg\")\r\n#     # plt.plot(data[\"nr_dirty\"], color='brown')\r\n#     # plt.plot(data[\"nr_clean\"], color='green')\r\n#     # plt.show()\r\n#\r\n#     # print(a_data)\r\n\r\n### legacy code #####\r\n# def load_countries(self):\r\n#     \"\"\"\r\n#     Initialise the country and fill the attributes from csv.\r\n#     All values have been sourced from real data and scaled into [0,1] using min-max scaling.\r\n#     Only \"Percentage_GDP_expenditure\" was not altered.\r\n#\r\n#     :return: None\r\n#     \"\"\"\r\n#     pred_dirties = np.empty(len(self.agents))\r\n#     pred_cleans = np.empty(len(self.agents))\r\n#\r\n#     # print(rands)\r\n#     rands1 = np.random.default_rng(self.seed+10).uniform(low=0.01, size=len(self.agents))\r\n#     rands2 = np.random.default_rng(self.seed+11).uniform(low=0.01, size=len(self.agents))\r\n#\r\n#     data = pd.read_csv(\"energy_model_v2.csv\", sep=\",\")\r\n#     for i, agent in enumerate(self.agents):\r\n#         self.schedule.add(agent)\r\n#         agent_data = data.loc[data['Country'] == agent.unique_id].reset_index()\r\n#\r\n#         # effective power plant output\r\n#         agent.pred_dirty = float(agent_data.at[0, \"pred_dirty\"])\r\n#         agent.pred_clean = float(agent_data.at[0, \"pred_clean\"])\r\n#\r\n#         pred_dirties[i] = float(agent_data.at[0, \"pred_dirty\"]) * 10\r\n#         pred_cleans[i] = float(agent_data.at[0, \"pred_clean\"]) * 10\r\n#         # energy\r\n#         agent.m_energy = agent_data.at[0, \"energy_demand\"] * \\\r\n#                          self.metab_e_scalar\r\n#         # money\r\n#         agent.influx_money = agent_data.at[0, \"gdp_influx\"]\r\n#\r\n#         agent.m_money = agent_data.at[0, \"Percentage_GDP_expenditure\"] * \\\r\n#                         agent_data.at[0, \"gdp_influx\"] * self.metab_m_scalar\r\n#\r\n#         agent.w_money = np.random.default_rng(self.seed+1).uniform(low=0.01, high=agent.influx_money)\r\n#         agent.w_energy = np.random.default_rng(self.seed+2).uniform(low=0.01, high=agent.influx_money)\r\n#\r\n#         # new\r\n#         # agent.w_energy = rands[i]\r\n#\r\n#         if agent.m_energy <= 0:\r\n#             agent.m_energy = 0.001\r\n#         if agent.m_money <= 0:\r\n#             agent.m_money = 0.001\r\n#         for attr in [\"pred_dirty\", \"pred_clean\", \"influx_money\"]:\r\n#             if getattr(agent, attr) <= 0:\r\n#                 setattr(agent, attr, 0.001)\r\n#         # need to collect to initialise wealth\r\n#         agent.collect()\r\n#         agent.calculate_welfare()\r\n#         agent.calculate_mrs()\r\n#\r\n#     # plt.figure()\r\n#     # # Plot a histogram of the values\r\n#     # plt.hist(pred_dirties, bins=50, edgecolor='black',alpha = 0.5,label = 'dirty')\r\n#     # plt.hist(pred_cleans, bins=50, edgecolor='black',alpha = 0.5,label = 'clean')\r\n#     #\r\n#     # # Add labels and title\r\n#     # plt.xlabel('Values')\r\n#     # plt.ylabel('Frequency')\r\n#     # plt.legend()\r\n#     # plt.title('Distribution of Values')\r\n#\r\n#     # Show plot\r\n#     # plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/geo_model2.py b/geo_model2.py
--- a/geo_model2.py	(revision 7c620acdf9d88ee719cb1becfe49b72376a81954)
+++ b/geo_model2.py	(date 1675777647339)
@@ -240,7 +240,7 @@
 
         self.schedule.step()
         self.trading_cycle()
-        self.tax_dirty()
+        #self.tax_dirty()
 
         self.log_data()
 
